package consume

import (
	"context"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/mitchellh/mapstructure"

	prom "github.com/bendbennett/go-api-demo/internal/consume"

	"github.com/bendbennett/go-api-demo/internal/log"

	"github.com/segmentio/kafka-go"
	"github.com/stretchr/testify/assert"
)

type readerMock struct {
}

func (r *readerMock) FetchMessage(ctx context.Context) (kafka.Message, error) {
	select {
	case <-ctx.Done():
		return kafka.Message{}, ctx.Err()
	default:
	}

	return kafka.Message{}, nil
}

func (r *readerMock) CommitMessages(context.Context, ...kafka.Message) error {
	return nil
}

func (r *readerMock) Stats() kafka.ReaderStats {
	return kafka.ReaderStats{}
}

type processorMock struct {
}

func (p *processorMock) Process(_ context.Context, id inputData) error {
	return nil
}

type logMock struct {
}

func (l *logMock) Panic(error) {
	panic("implement me")
}

func (l *logMock) Panicf(string, ...interface{}) {
	panic("implement me")
}

func (l *logMock) Error(error) {
	panic("implement me")
}

func (l *logMock) Errorf(string, ...interface{}) {
	panic("implement me")
}

func (l *logMock) Infof(string, ...interface{}) {
}

func (l *logMock) WithSpan(context.Context) log.Logger {
	panic("implement me")
}

// TODO: Consume only returns error when context is cancelled.
// Once the event handling for error conditions is in place,
// should test whether events are being pushed onto retry topic
// or not. For errors generated by unmarshalling, a separate
// topic from the retry topic should be implemented.
func TestUserConsumer_Consume(t *testing.T) {
	cases := []struct {
		name     string
		consumer *c
	}{
		{
			"user consumer consume logs and returns nil",
			&c{
				reader:      &readerMock{},
				consumeFunc: consume,
				processor:   &processorMock{},
				log:         &logMock{},
				promCollector: prom.PromCollector{
					Interval: time.Second,
				},
			},
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			ctx, cancel := context.WithCancel(context.Background())
			cancel()
			err := c.consumer.Run(ctx)

			assert.NoError(t, err)
		})
	}
}

var msg = map[string]interface{}{
	"after": map[string]interface{}{
		"go_api_demo_db.go_api_demo.users.Value": map[string]interface{}{
			"created_at": 1639512014000,
			"first_name": "john",
			"id":         "673b3c8c-3589-4b77-af89-94dcda52a861",
			"last_name":  "smith",
		},
	},
	"before": nil,
	"op":     "c",
	"source": map[string]interface{}{
		"connector": "mysql",
		"db":        "go-api-demo",
		"file":      "binlog.000002",
		"gtid":      nil,
		"name":      "go_api_demo_db",
		"pos":       9548,
		"query":     nil,
		"row":       0,
		"sequence":  nil,
		"server_id": 1,
		"snapshot": map[string]interface{}{
			"string": "false",
		},
		"table": map[string]interface{}{
			"string": "users",
		},
		"thread":  nil,
		"ts_ms":   1639512013000,
		"version": "1.7.1.Final",
	},
	"transaction": nil,
	"ts_ms": map[string]interface{}{
		"long": 1639512013850,
	},
}

// nolint:gocyclo
func Benchmark_Extract(b *testing.B) {
	extractUser := func(msg interface{}, key string) (usr, error) {
		valKey := "go_api_demo_db.go_api_demo.users.Value"

		if _, ok := msg.(map[string]interface{}); !ok {
			return usr{}, errors.New("cannot assert msg as map[string]interface{}")
		}

		m := msg.(map[string]interface{})

		if _, ok := m[key]; !ok {
			return usr{}, fmt.Errorf("%v key missing from msg", key)
		}

		if m[key] == nil {
			return usr{}, nil
		}

		if _, ok := m[key].(map[string]interface{}); !ok {
			return usr{}, fmt.Errorf("cannot assert msg[%v] as map[string]interface{}", key)
		}

		m = m[key].(map[string]interface{})

		if _, ok := m[valKey]; !ok {
			return usr{}, fmt.Errorf("%v key missing from msg", valKey)
		}

		if _, ok := m[valKey].(map[string]interface{}); !ok {
			return usr{}, fmt.Errorf("cannot assert msg[%v][%v] as map[string]interface{}", key, valKey)
		}

		m = m[valKey].(map[string]interface{})

		reqKeys := []string{"id", "first_name", "last_name", "created_at"}

		for _, reqKey := range reqKeys {
			if _, ok := m[reqKey]; !ok {
				return usr{}, fmt.Errorf("%v key missing from msg", reqKey)
			}
		}

		if _, ok := m["id"].(string); !ok {
			return usr{}, errors.New("cannot assert id is string")
		}

		if _, ok := m["first_name"].(string); !ok {
			return usr{}, errors.New("cannot assert first_name is string")
		}

		if _, ok := m["last_name"].(string); !ok {
			return usr{}, errors.New("cannot assert last_name is string")
		}

		if _, ok := m["created_at"].(int64); !ok {
			return usr{}, errors.New("cannot assert created_at is int64")
		}

		return usr{
			ID:        m["id"].(string),
			FirstName: m["first_name"].(string),
			LastName:  m["last_name"].(string),
			CreatedAt: m["created_at"].(int64),
		}, nil
	}

	for n := 0; n < b.N; n++ {
		_, _ = extractUser(msg, "after")

	}
}

func Benchmark_MapExtract(b *testing.B) {
	m := m{}

	for n := 0; n < b.N; n++ {
		_ = mapstructure.Decode(msg, &m)

	}
}
